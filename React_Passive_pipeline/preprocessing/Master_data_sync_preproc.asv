function Master_data_sync_preproc(sessions, do_plot)
% Master_data_sync_preproc
% React_Passive_AG master wrapper: sync all data streams and build epochs.
%
% INPUT
%   sessions : cell array of session folders, e.g.
%       sessions = {
%         '/home/Arsenii/React_Passive/Processed_data/Edel/20220419_1_m_C'
%         '/home/Arsenii/React_Passive/Processed_data/Kosichka/20220309_1_m_A'
%         '/home/Arsenii/React_Passive/Processed_data/Chabichou/20220301_1_m_A'
%         ...
%       };

if nargin < 2 || isempty(do_plot)
    do_plot = false;
end

if ~iscell(sessions)
    error('Input "sessions" must be a cell array of session paths');
end

for sess = 1:numel(sessions)
    datapath = sessions{sess};
    disp('------------------------------------------')
    disp(['Working on ' datapath])
    
    if ~isfolder(datapath)
        warning(['Folder not found, skipping: ' datapath])
        continue
    end
    
    try
        % 0) Check which modalities are available
        lfp_dir = fullfile(datapath,'ephys','LFPData');
        has_OE = isfolder(lfp_dir) && ~isempty(dir(fullfile(lfp_dir,'LFP*.mat')));
        
        % 1) Passive-specific csv sync for Edel and Chabichou (and other csv-only cases which probably will never exist)
        trig_csv = [];
        if contains(datapath,'Edel') || contains(datapath,'Chabichou')
            disp('  [1] Syncing Baphy–fUS from csv (RP_sync_triggers_passive)...')
            trig_csv = RP_sync_triggers_passive(datapath);
        else
            disp('  [1] No csv sync step for this animal (skip RP_sync_triggers_passive).')
        end
        
        % 2-3) Get channel configuration and extract TTLs from OE for this session
        trigOE = [];
        if has_OE
            disp('  [2] Loading trigger channel config (get_trigger_config)...')
            cfg = get_trigger_config(datapath);
            cfg.plt = do_plot;
            disp('  [3] Extracting OE TTL triggers (extract_triggers_oe)...')
            trigOE = extract_triggers_oe(datapath, cfg);
          
        else
            disp('  [2-3] No LFPData/OpenEphys for this session, skipping OE TTL extraction.');
        end
        
        % 4) Parse Baphy m-file for React Passive (categories, timings, etc.)
        if contains(datapath, 'Edel') || contains(datapath, 'Chabichou') || contains(datapath, 'Kosichka')
            disp('  [4] Parsing Baphy file (RP_parse_baphy_passive)...')
            Baphy = RP_parse_baphy_passive(datapath);
        elseif contains(datapath, 'Tvorozhok') && contains(datapath, 'Mochi')
            disp('  [4] Parsing Baphy file (RA_parse_baphy_active)...')
            Baphy = RA_parse_baphy_active(datapath);
        else
            disp('unknown animal, I am lost....')
        end
        
        % 4b) Regularise / check TTLs
        if has_OE && ~isempty(trigOE)
            disp('  [4b] Regularising OE TTLs (regularize_all_ttl)...')
            try
                trigOE = regularize_all_ttl(trigOE, Baphy, datapath);
            catch MEreg
                warning('regularize_all_ttl crashed: %s', MEreg.message);
            end
            
            if do_plot && isfield(trigOE,'fus') && isfield(trigOE.fus,'t_s') ...
                    && ~isempty(trigOE.fus.t_s)
                figure('Name',['OE fUS raw vs regularised TTLs - ' datapath],'NumberTitle','off');
                hold on 
                plot(trigOE.fus.t_s, 1, 'r*');
                plot(trigOE.fus.t_raw_ts/1e4, 1, 'b*');
                plot(trigOE.fus.t_s(find(ismember(trigOE.fus.t_s, trigOE.fus.t_raw_ts/1e4)==0)), 0.99, 'g*');
                xlabel('Time (s)'); ylim([0 2]);
                title('OE fUS raw vs regularised TTLs');
            end
            
        elseif ~has_OE && ~isempty(trig_csv)
            disp('  [4b] Regularising csv TTLs (regularize_all_ttl_csv)...')
            trig_csv = regularize_all_ttl_csv(trig_csv, Baphy, datapath);
            
            if do_plot && isfield(trig_csv,'fus_time_s') && ~isempty(trig_csv.fus_time_s)
                figure('Name',['csv fUS TTL - ' datapath],'NumberTitle','off');                
                plot(trig_csv.fus_time_s, ones(size(trig_csv.fus_time_s)), 'k*');
                xlabel('Time (s)'); ylim([0.5 1.5]);
                title('csv fUS TTLs (after regularisation)');
            end
        else
            disp('  [4b] No TTLs available for regularisation/checking.');
        end
        
        % 4c) Edel-specific: derive Baphy trial info from OE TTL bursts
        if has_OE && contains(datapath,'Edel')
            disp('  [4c] Extracting Edel Baphy trial info from OE TTLs...')
            trigOE = RP_add_baphy_trial_info_from_ttl(trigOE, trig_csv, Baphy, datapath);
        end
        
        % 5) Build epochs on the OE/common time axis
        if has_OE
            disp('  [5] Building epochs (RP_build_epochs_passive)...')
            Epochs = RP_build_epochs_passive(datapath, trigOE, Baphy);
        else
            disp('  [5] Building epochs from csv only (RP_build_epochs_passive_csv_only)...')
            if isempty(trig_csv)
                error('Master_data_sync_preproc:NoCSVForCsvOnly', ...
                    'csv-only session but trig_csv is empty. Check RP_sync_triggers_passive.');
            end
            Epochs = RP_build_epochs_passive_csv_only(datapath, trig_csv, Baphy);
        end
        
        % 6) Optional trial-count sanity check (now using scalar counts)
        if exist('check_trial_counts','file') == 2
            try
                disp('[6] Checking trial counts (check_trial_counts)...')
                
                % n_oe: from OE Baphy TTLs, if available
                n_oe = [];
                if ~isempty(trigOE) && isfield(trigOE,'baphy')
                    if isfield(trigOE.baphy,'t_s') && ~isempty(trigOE.baphy.t_s)
                        n_oe = numel(trigOE.baphy.t_s);
                    elseif isfield(trigOE.baphy,'t_raw_s') && ~isempty(trigOE.baphy.t_raw_s)
                        [t_on_oe, ~] = detect_trial_onsets_from_baphy_ttl(datapath, trigOE.baphy.t_raw_s, Baphy.n_trials);
                        n_oe = numel(t_on_oe);
                    end
                end
                
                % n_csv: from csv Baphy TTLs, if available
                n_csv = [];
                if ~isempty(trig_csv) && isfield(trig_csv,'baphy_time_s') && ~isempty(trig_csv.baphy_time_s)
                    [t_on_csv, ~] = detect_trial_onsets_from_baphy_ttl(datapath, trig_csv.baphy_time_s, Baphy.n_trials);
                    n_csv = numel(t_on_csv);
                end
                
                % n_baphy: from Baphy metadata
                n_baphy = Baphy.n_trials;
                
                check_trial_counts(n_oe, n_baphy, n_csv, datapath, 'RP_passive');
                
            catch ME_chk
                warning('check_trial_counts crashed: %s', ME_chk.message);
            end
        else
            disp('  [4e] check_trial_counts.m not found, skipping.');
        end
        
        % Small textual summary
        n_csv_baphy = 0;
        if ~isempty(trig_csv) && isfield(trig_csv,'baphy_time_s')
            n_csv_baphy = numel(trig_csv.baphy_time_s);
        end
        n_oe_baphy = 0;
        if ~isempty(trigOE) && isfield(trigOE,'baphy') && isfield(trigOE.baphy,'t_raw_s')
            n_oe_baphy = numel(trigOE.baphy.t_raw_s);
        end
        fprintf('  Summary: Baphy-trials=%d | csv-Baphy-TTL=%d | OE-Baphy-TTL=%d\n', ...
            Baphy.n_trials, n_csv_baphy, n_oe_baphy);
        
        
        % 6) Save everything in one place
        out_file = fullfile(datapath, 'Master_sync.mat');
        save(out_file, 'trig_csv', 'trigOE', 'Baphy', 'Epochs');
        disp(['  Saved master sync file: ' out_file])
        
    catch ME
        warning('Error in session %s:\n  %s', datapath, ME.message);
        disp(getReport(ME,'basic'))
        continue
    end
end

disp('Master_data_sync_preproc finished.')

end
